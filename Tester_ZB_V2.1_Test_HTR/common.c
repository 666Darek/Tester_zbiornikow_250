/*
 * common.c
 *
 *  Created on: 22 lip 2020
 *      Author: Dawid Sobków
 */

#include "common.h"

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <string.h>

#include "ds_GFX/ds_GFX.h"
#include "T6963C.h"
#include "ADC/adc.h"

uint8_t pressSensorType = MPX4250AP;
//uint16_t pressSensorOffset = 360;

uint8_t printerSelected = MI2400;
uint8_t startMethod = START_TOGGLE;
uint8_t startMode = START_MODE_WHENALL;
uint8_t startButtonFlag = 0;

int S_AV_REF=163;
int S_P_offset=100;
int S_pressure=70;//cisnienie sprawdzania
int S_pressure_error=2;//jaki blad cisnienia mozliwy

//zmienne 8-bitowe stanow zatrzaskow
static char LATCH0;
static char LATCH1;
static char LATCH2;

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC2                  */
/*---------------------------------------------------------*/
ISR(TIMER0_COMP_vect)
{
	uint16_t x;
	x = Timer150;
	if (x) Timer150 = --x;
	x = Timer1;
	if (x) Timer1 = --x;
	x = Timer2;
	if (x) Timer2 = --x;
//	x = TimerRelay;
//	if (x) TimerRelay = --x;
}

//***********************************************************************************************************
//
//Funkcja sygnalu dzwiekowego bledu
//
//***********************************************************************************************************
void BEEP_ERROR(void)
{
		//wlaczenie beeperka sygnal dzwiekowy
		BUZER_ON;
		_delay_ms(430);
		BUZER_OFF;
		_delay_ms(100);
		BUZER_ON;
		_delay_ms(100);
		BUZER_OFF;
		_delay_ms(100);
		BUZER_ON;
		_delay_ms(100);
		BUZER_OFF;
		_delay_ms(1000);
}
//***********************************************************************************************************
//
//Funkcja sygnalu dzwiekowego poprawnosci
//
//***********************************************************************************************************
void BEEP_GOOD(void)
{
		//wlaczenie beeperka sygnal dzwiekowy
		BUZER_ON;
		_delay_ms(250);
		BUZER_OFF;
		_delay_ms(70);
		BUZER_ON;
		_delay_ms(250);
		BUZER_OFF;
		_delay_ms(70);
		BUZER_ON;
		_delay_ms(70);
		BUZER_OFF;
}

//***********************************************************************************************************
//
//	Funkcja sterujaca zatrzaskami
//
//***********************************************************************************************************
void LATCH_CONTROL(char adr, char bit, char on)
{
//podawane jest ardes zatrzasku, ktory bit, oraz czy wlaczyc czy wylaczyc
switch(adr)
	{
	case 0:
		{
			if(on)LATCH0|=_BV(bit);//gdy wlaczamy to logicznie OR z tym co bylo wczesniej na zatrzasku
			else LATCH0&=~_BV(bit);//gdy wylaczamy to logiczny AND NOT z tym co bylo wczesniej
			BIT_DATA_PORT=LATCH0;//ustawiamy port na zmienna konkretnego zatrzask
			PORTB|=_BV(4);//tykniecie Enable-m by przepisac z wejsc na wyjscia zatrzaskow
			_delay_ms(10);
			PORTB&=~_BV(4);
		}break;
	case 1:
		{
			if(on)LATCH1|=_BV(bit);
			else LATCH1&=~_BV(bit);
			BIT_DATA_PORT=LATCH1;//ustawiamy port na zmienna konkretnego zatrzasku
			PORTB|=_BV(3);
			_delay_ms(10);
			PORTB&=~_BV(3);
		}break;
	case 2:
		{
			if(on)LATCH2|=_BV(bit);
			else LATCH2&=~_BV(bit);
			BIT_DATA_PORT=LATCH2;//ustawiamy port na zmienna konkretnego zatrzasku
			PORTB|=_BV(2);
			_delay_ms(10);
			PORTB&=~_BV(2);
		}break;
	}//switch
}

//***********************************************************************************************************
//
//Funkcja zapalajaca diody sygnalizacyjne
//
//***********************************************************************************************************
void LED_STATUS_ON(char socket, char status)
{
switch(socket)
	{
		case 0:{//wynik dla zbiornika 1
					if(status==1)G1_ON;
					else R1_ON;
				}break;
		case 1:{//wynik dla zbiornika 2
					if(status==1)G2_ON;
					else R2_ON;
				}break;
		case 2:{//wynik dla zbiornika 3
					if(status==1)G3_ON;
					else R3_ON;
				}break;
		case 3:{//wynik dla zbiornika 4
					if(status==1)G4_ON;
					else R4_ON;
				}break;
		case 4:{//wynik dla zbiornika 5
					if(status==1)G5_ON;
					else R5_ON;
				}break;
	}//switch
}
//***********************************************************************************************************
//
//Funkcja gasz¹ca diody sygnalizacyjne
//
//***********************************************************************************************************
void LED_STATUS_OFF(char socket)
{
switch(socket)
	{
		case 0:{//wynik dla zbiornika 1
					G1_OFF;
					R1_OFF;
				}break;
		case 1:{//wynik dla zbiornika 2
					G2_OFF;
					R2_OFF;
				}break;
		case 2:{//wynik dla zbiornika 3
					G3_OFF;
					R3_OFF;
				}break;
		case 3:{//wynik dla zbiornika 4
					G4_OFF;
					R4_OFF;
				}break;
		case 4:{//wynik dla zbiornika 5
					G5_OFF;
					R5_OFF;
				}break;
	}//switch
}

//***********************************************************************************************************
//
//Funkcja zaspisu bajtu do EEPROM-u
//
//***********************************************************************************************************
void EEPROM_BYTE_WRITE(unsigned int Address, unsigned char Data)
{
	while(EECR & (1<<EEWE));//czekaj na zakonczenie poprzedniego zapisu/odczytu
	EEAR = Address;//ustaw adres komorki do zapisu
	EEDR = Data;//ustaw dana w rejestrze do zapisu
	EECR |= (1<<EEMWE);//wpisanie logicznej 1 do znacznika EEMWE
	EECR |= (1<<EEWE);//rozpocznij zapisywanie przez ustawienie rejestru EEWE
}
//***********************************************************************************************************
//
//Funkcja odczytu bajtu z EEPROM-u
//
//***********************************************************************************************************
unsigned char EEPROM_BYTE_READ(unsigned int uiAddress)
{
	unsigned char Data;
	while(EECR & (1<<EEWE));//czekaj na zakonczenie poprzedniego odczytu/zapisu
	EEAR = uiAddress;//ustaw adres komorki do odczytania
	EECR |= (1<<EERE);//rozpocznij czytanie przez ustawienie rejestru EERE
	Data=EEDR;//przepisanie wartosci z komorki do zmiennej
	return Data;//zwraca wartosc komowki pamieci
}
//***********************************************************************************************************
//
//Funkcja zapisu danych do EEPROM-u
//
//***********************************************************************************************************
void EEPROM_WRITE(unsigned int adress1, void * Data,short Data_length)
{
//funkcja zapisuje zmienna Data dowolnego typu, poczawszy od adress1, przez liczbe bajtow Data_length
for(int a=0;a<Data_length;a++)
	{
		EEPROM_BYTE_WRITE(adress1++,*((unsigned char*)Data+a));
		//zapis pojedynczego bajtu z podzieleniem danej Data przez rzutowanie
		//na 8bitow(unsigned char)a w dalszych krokach petli przesuwanie
		//wskaznika na kilejne 8 bitow (bajt) danej
		//					FORMAT WPROWADZANIA
		//EEPROM_WRITE(adres , (unsigned char*)&dana , dlugosc_w_bajtach);
	}
}
//***********************************************************************************************************
//
//Funkcja odczytu danych z EEPROM-u
//
//***********************************************************************************************************
void EEPROM_READ(unsigned int adress1, void * Data,short Data_length)
{
//funkcja odczytuje zmienna z zadanego adresu i dlugosci w bajtach przekazujac ja w parametrze (zmienna moze byc dowolnego typu)
for(int a=0;a<Data_length;a++)
	{
		*((unsigned char*)Data+a) = EEPROM_BYTE_READ(adress1++);
		//odczyt pojedynczego bajtu z danego adresu
		//nastepnie przesuwanie adresu oraz przypisanie wartosci z tej komorki
		//do kolejnych 8 bitow zmienej dowolnego typu -> Data
		//					FORMAT WPROWADZANIA
		//EEPROM_READ(adres , (unsigned char*)&dana , dlugosc_w_bajtach);
	}
}

//***********************************************************************************************************
//
//Funkcja przelaczajaca zawory
//
//***********************************************************************************************************
void VALVE_CONTROL(char socket, char operate)
{
switch(socket)
{
case 0: {//case od 1 socketu
			switch(operate)
			{
				case 1:{//wlaczenie napelniania worka, oproznianie otoczenia
							Z1A_ON;
							Z1B_OFF;
							Z1C_ON;
						}break;
				case 2:{//przelaczenia na pomiar cisnienia
							Z1A_OFF;
						}break;
				case 3:{//napelnianie otoczenia, oproznianie worka
							Z1A_ON;
							Z1B_ON;
							Z1C_OFF;
						}break;
				case 4:{//wylaczenie zaworow
							Z1A_OFF;
							Z1B_OFF;
							Z1C_OFF;
						}break;
				case 5:{//spuszczenie powietrza z otoczenia
					//V1-0	V2-0	V3-1
							Z1C_ON;
							Z1A_OFF;
							Z1B_OFF;
						}break;
				case 6:{//przelacz kanal‚ pomiaru na worek (ale bedzie tutaj otwarte do atmosfery)
							Z1B_OFF;
						}break;
				case 7:{//wlacz oproznianie zbiornika - tak by wytworzyl podcisnienie w worku (bo jest zamkniety na pomiar w worku)
							Z1C_ON;
						}break;
			}//switch (operate)
		}break;
case 1: {//case od 2 socketu
	switch(operate)
			{
				case 1:{//wlaczenie napelniania worka, oproznianie otoczenia
							Z2A_ON;
							Z2B_OFF;
							Z2C_ON;
						}break;
				case 2:{//przelaczenia na pomiar cisnienia
							Z2A_OFF;
						}break;
				case 3:{//napelnianie otoczenia, oproznianie worka
							Z2A_ON;
							Z2B_ON;
							Z2C_OFF;
						}break;
				case 4:{//wylaczenie zaworow
							Z2A_OFF;
							Z2B_OFF;
							Z2C_OFF;
						}break;
				case 5:{//spuszczenie powietrza z otoczenia
					//V1-0	V2-0	V3-1
							Z2C_ON;
							Z2A_OFF;
							Z2B_OFF;
						}break;
				case 6:{//przelacz kanal‚ pomiaru na worek (ale bedzie tutaj otwarte do atmosfery)
							Z2B_OFF;
						}break;
				case 7:{//wlacz oproznianie zbiornika - tak by wytworzyl podcisnienie w worku (bo jest zamkniety na pomiar w worku)
							Z2C_ON;
						}break;
			}//switch (operate)
		}break;
case 2: {//case od 3 socketu
			switch(operate)
			{
				case 1:{//wlaczenie napelniania worka, oproznianie otoczenia
							Z3A_ON;
							Z3B_OFF;
							Z3C_ON;
						}break;
				case 2:{//przelaczenia na pomiar cisnienia
							Z3A_OFF;
						}break;
				case 3:{//napelnianie otoczenia, oproznianie worka
							Z3A_ON;
							Z3B_ON;
							Z3C_OFF;
						}break;
				case 4:{//wylaczenie zaworow
							Z3A_OFF;
							Z3B_OFF;
							Z3C_OFF;
						}break;
				case 5:{//spuszczenie powietrza z otoczenia
					//V1-0	V2-0	V3-1
							Z3C_ON;
							Z3A_OFF;
							Z3B_OFF;
						}break;
				case 6:{//przelacz kanal‚ pomiaru na worek (ale bedzie tutaj otwarte do atmosfery)
							Z3B_OFF;
						}break;
				case 7:{//wlacz oproznianie zbiornika - tak by wytworzyl podcisnienie w worku (bo jest zamkniety na pomiar w worku)
							Z3C_ON;
						}break;
			}//switch (operate)
		}break;
case 3: {//case od 4 socketu
			switch(operate)
			{
				case 1:{//wlaczenie napelniania worka, oproznianie otoczenia
							Z4A_ON;
							Z4B_OFF;
							Z4C_ON;
						}break;
				case 2:{//przelaczenia na pomiar cisnienia
							Z4A_OFF;
						}break;
				case 3:{//napelnianie otoczenia, oproznianie worka
							Z4A_ON;
							Z4B_ON;
							Z4C_OFF;
						}break;
				case 4:{//wylaczenie zaworow
							Z4A_OFF;
							Z4B_OFF;
							Z4C_OFF;
						}break;
				case 5:{//spuszczenie powietrza z otoczenia
					//V1-0	V2-0	V3-1
							Z4C_ON;
							Z4A_OFF;
							Z4B_OFF;
						}break;
				case 6:{//przelacz kanal‚ pomiaru na worek (ale bedzie tutaj otwarte do atmosfery)
							Z4B_OFF;
						}break;
				case 7:{//wlacz oproznianie zbiornika - tak by wytworzyl podcisnienie w worku (bo jest zamkniety na pomiar w worku)
							Z4C_ON;
						}break;
			}//switch (operate)
		}break;
case 4: {//case od 5 socketu
			switch(operate)
			{
				case 1:{//wlaczenie napelniania worka, oproznianie otoczenia
							Z5A_ON;
							Z5B_OFF;
							Z5C_ON;
						}break;
				case 2:{//przelaczenia na pomiar cisnienia
							Z5A_OFF;
						}break;
				case 3:{//napelnianie otoczenia, oproznianie worka
							Z5A_ON;
							Z5B_ON;
							Z5C_OFF;
						}break;
				case 4:{//wylaczenie zaworow
							Z5A_OFF;
							Z5B_OFF;
							Z5C_OFF;
						}break;
				case 5:{//spuszczenie powietrza z otoczenia
					//V1-0	V2-0	V3-1
							Z5C_ON;
							Z5A_OFF;
							Z5B_OFF;
						}break;
				case 6:{//przelacz kanal‚ pomiaru na worek (ale bedzie tutaj otwarte do atmosfery)
							Z5B_OFF;
						}break;
				case 7:{//wlacz oproznianie zbiornika - tak by wytworzyl podcisnienie w worku (bo jest zamkniety na pomiar w worku)
							Z5C_ON;
						}break;
			}//switch (operate)
		}break;
	}
}

void CheckPressureMidWorking()
{
	int Pressure;
	int Pressure_KPA;

	static char ERROR_OF_PRESSURE=0;

//	Pressure=ADC_CZUJNIK[CZUJNIK_6];//pomiar z czujnika glownego
	Pressure=pomiar( CZUJNIK_6 );//pomiar z czujnika glownego
//	Pressure=ADC_CZUJNIK_6;//pomiar z czujnika glownego
//	Pressure=pomiar(CZUJNIK_1);//pomiar z czujnika glownego
	Pressure_KPA=(PRESSURE_CONVERT(Pressure));//pomiar cisnienia dla czujnika absolutnego dlatego odejmujemy 100kPa - czyli cisnienie atmosferyczne
	//powyzej bez odejmowania 100 kPa bo jest przez wzmacniacza i tylko 85 - 115 kPa dzia³a

	if(ERROR_OF_PRESSURE == 1 || (Pressure_KPA < (S_pressure-S_pressure_error) || Pressure_KPA > (S_pressure+S_pressure_error)))
	{
		ERROR_OF_PRESSURE = 1;

		LCD_ClearText();

		if(Pressure_KPA < (S_pressure-S_pressure_error))
		{
			LCD_TextGoTo(0,1);
			LCD_WRiteString("             BLAD CISNIENIA");
			LCD_TextGoTo(0,3);

			LCD_WRiteString("     CISNIENIE JEST ZA NISKIE ");
			LCD_WRiteString(" P=");
			LCD_WriteINT(Pressure_KPA);

			LCD_TextGoTo(0,5);
			LCD_WRiteString("          ZWIEKSZ DO P=");
			LCD_WriteINT(S_pressure);

			LCD_TextGoTo(26,5);
			LCD_WRiteString(" [kPa]");
		}
		else if(Pressure_KPA > (S_pressure+S_pressure_error))
		{
			LCD_TextGoTo(0,1);
			LCD_WRiteString("             BLAD CISNIENIA");
			LCD_TextGoTo(0,3);

			LCD_WRiteString("      CISNIENIE JEST ZA WYSOKIE");
			LCD_WRiteString(" P=");
			LCD_WriteINT(Pressure_KPA);

			LCD_TextGoTo(0,5);
			LCD_WRiteString("          ZMNIEJSZ DO P=");
			LCD_WriteINT(S_pressure);
			LCD_TextGoTo(28,5);
			LCD_WRiteString("[kPa]");
		}
		else
			ERROR_OF_PRESSURE = 0;
	}
	else if(ERROR_OF_PRESSURE == 0)
	{

	}
}
